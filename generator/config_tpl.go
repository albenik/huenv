package generator

import (
	"bytes"
	"fmt"
	"io"
	"sort"
	"strconv"
	"strings"
	"text/template"

	"github.com/albenik/huenv/internal/version"
	"github.com/albenik/huenv/reflector"
	"github.com/albenik/huenv/unmarshal"
)

const unmarshalPkg = "github.com/albenik/huenv/unmarshal"

type configTemplateData struct {
	GeneratorVersion string
	Package          string
	ConfigType       string
	Imports          []*configTemplateImport
	Envs             []*configTemplateTargetInfo
}

type configTemplateImport struct {
	Alias string
	Path  string
}

type configTemplateTargetInfo struct {
	Env         string
	Field       string
	Condition   interface{}
	Unmarshaler configTemplateUnmarshalerName
}

type configTemplateUnmarshalerName struct {
	Package string // package import path or name
	Type    string // type name without package
}

func (n configTemplateUnmarshalerName) String() string {
	return fmt.Sprintf("%s.%s", n.Package, n.Type)
}

type ConfigGenerator struct {
	importsAliases map[string]string
}

func (g *ConfigGenerator) Generate(dst io.Writer, info *reflector.Result) error {
	buf := new(bytes.Buffer)

	data := &configTemplateData{
		GeneratorVersion: version.String(),
		Package:          info.ConfigPkg,
		ConfigType:       info.ConfigType,
		Imports:          nil,
		Envs:             nil,
	}
	if err := g.fillTemplateData(data, info); err != nil {
		return err
	}

	if err := g.configTemplate().Execute(buf, data); err != nil {
		return err
	}

	// keep source code to provide with the gofmt error if it happens
	src := buf.Bytes()

	if err := formatSource(dst, bytes.NewReader(src)); err != nil {
		return &CodegenError{
			wrapped: err,
			source:  src,
		}
	}

	return nil
}

func (g *ConfigGenerator) fillTemplateData(data *configTemplateData, info *reflector.Result) error {
	delete(info.Packages, unmarshalPkg)

	pkgKeys := make([]string, 0, len(info.Packages))
	for k := range info.Packages {
		pkgKeys = append(pkgKeys, k)
	}
	sort.Strings(pkgKeys)

	g.importsAliases = make(map[string]string, len(pkgKeys))
	data.Imports = make([]*configTemplateImport, 0, len(pkgKeys))
	for i, k := range pkgKeys {
		alias := fmt.Sprintf("_pkg%d", i+1)
		g.importsAliases[k] = alias
		data.Imports = append(data.Imports, &configTemplateImport{
			Alias: alias,
			Path:  k,
		})
	}

	envKeys := make([]string, 0, len(info.Envs))
	for k := range info.Envs {
		envKeys = append(envKeys, k)
	}
	sort.Strings(envKeys)
	envKeys = reflector.SortWithDeps(envKeys, info.Envs)

	data.Envs = make([]*configTemplateTargetInfo, 0, len(envKeys))
	for _, k := range envKeys {
		e := info.Envs[k]
		data.Envs = append(data.Envs, &configTemplateTargetInfo{
			Env:         k,
			Field:       e.Field.Name,
			Condition:   e.Condition,
			Unmarshaler: g.adaptUnmarshalerName(e.Field.Unmarshaler),
		})
	}

	return nil
}

func (g *ConfigGenerator) adaptUnmarshalerName(name unmarshal.UnmarshalerName) configTemplateUnmarshalerName {
	uname := configTemplateUnmarshalerName(name)
	if uname.Package == unmarshalPkg {
		uname.Package = "_u"
	} else {
		uname.Package = g.importsAliases[uname.Package]
	}
	return uname
}

func (g *ConfigGenerator) printCondition(prefix string, condition interface{}) (string, error) {
	switch c := condition.(type) {
	case reflector.ConditionRequired:
		if c {
			return "_u.Required()", nil
		}
		return "_u.Optional()", nil

	case reflector.ConditionEnum:
		quoted := make([]string, 0, len(c))
		for _, s := range c {
			quoted = append(quoted, strconv.Quote(s))
		}
		return fmt.Sprintf("_u.Enum(%s)", strings.Join(quoted, ",")), nil

	case *reflector.ConditionRequireIf:
		return fmt.Sprintf("_u.RequireIf(%s.%s, %q, new(%s))", prefix, c.Target.Name, c.ValueStr,
			g.adaptUnmarshalerName(c.Target.Unmarshaler)), nil

	case *reflector.ConditionRequireIfCombined:
		var (
			s1, s2 string
			err    error
		)

		if s1, err = g.printCondition(prefix, c.First); err == nil {
			s2, err = g.printCondition(prefix, c.Second)
		}
		if err != nil {
			return "", err
		}

		return s1 + fmt.Sprintf(".And(%s)", s2), nil

	default:
		return "", fmt.Errorf("unknown condition type %T", c)
	}
}

func (g *ConfigGenerator) configTemplate() *template.Template {
	return template.Must(template.New("config").
		Funcs(template.FuncMap{"printCondition": g.printCondition}).
		Parse(`// DO NOT EDIT! Code generated by github.com/albenik/huenv/cmd/huenv@{{ .GeneratorVersion }}.

package {{ .Package }}

import (
	{{- range .Imports }}
	{{ .Alias }} {{ printf "%q" .Path }}
	{{ end }}
	_u "github.com/albenik/huenv/unmarshal"
)

func (c *{{ .ConfigType }}) Envmap() map[string]*_u.Target {
	to := _u.NewTarget

	return map[string]*_u.Target{
	{{- range .Envs }}
		"{{ .Env }}": to(&c.{{ .Field }}, new({{ .Unmarshaler }}), {{ printCondition "&c" .Condition }}),
	{{- end }}
	}
}
`))
}
