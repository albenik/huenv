package generator_test

import (
	"bytes"
	"errors"
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/albenik/huenv/generator"
	"github.com/albenik/huenv/reflector"
	"github.com/albenik/huenv/unmarshal"
)

func TestGenerateConfigFuncSource(t *testing.T) {
	const expectedOutput = `// DO NOT EDIT! Code generated by github.com/albenik/huenv/cmd/huenv@undefined.

package testpkg

import (
	_u "github.com/albenik/huenv/unmarshal"
)

var _to = _u.NewTarget

func (c *TestConfig) Envmap() map[string]*_u.Target {
	return map[string]*_u.Target{
		"ENV_BOOL":             _to(&c.Bool, new(_u.Bool), _u.Required()),
		"ENV_BOOL_DEP_B":       _to(&c.BoolDepB, new(_u.Bool), _u.RequireIf(&c.Bool, "true", new(_u.Bool))),
		"ENV_BOOL_DEP_S":       _to(&c.BoolDepS, new(_u.Bool), _u.RequireIf(&c.String, "foo", new(_u.String))),
		"ENV_BOOL_OPT":         _to(&c.BoolOpt, new(_u.Bool), _u.Optional()),
		"ENV_CCC":              _to(&c.Ccc, new(_u.String), _u.RequireIf(&c.String, "foo", new(_u.String)).And(_u.Enum("foo", "bar", "baz"))),
		"ENV_STRING":           _to(&c.String, new(_u.String), _u.Required()),
		"ENV_VERY_LOOOOOOOONG": _to(&c.URL, new(_u.URL), _u.Required()),
	}
}
`

	const (
		pkg               = "github.com/albenik/huenv/unmarshal"
		stringUnmarshaler = "String"
		boolUnmarshaler   = "Bool"
		urlUnmarshaler    = "URL"
	)

	buf := new(bytes.Buffer)
	err := new(generator.ConfigGenerator).Generate(buf, &reflector.Result{
		ConfigPkg:  "testpkg",
		ConfigType: "TestConfig",
		Packages: map[string]struct{}{
			"github.com/albenik/huenv/unmarshal": {},
		},
		Envs: map[string]*reflector.TargetInfo{
			"ENV_BOOL": {
				Target: &reflector.Target{
					Field: "Bool",
					Unmarshaler: unmarshal.UnmarshalerName{
						Package: pkg,
						Type:    boolUnmarshaler,
					},
				},
				Condition: reflector.ConditionRequired(true),
			},
			"ENV_BOOL_OPT": {
				Target: &reflector.Target{
					Field: "BoolOpt",
					Unmarshaler: unmarshal.UnmarshalerName{
						Package: pkg,
						Type:    boolUnmarshaler,
					},
				},
				Condition: reflector.ConditionRequired(false),
			},
			"ENV_BOOL_DEP_B": {
				Target: &reflector.Target{
					Field: "BoolDepB",
					Unmarshaler: unmarshal.UnmarshalerName{
						Package: pkg,
						Type:    boolUnmarshaler,
					},
				},
				Condition: &reflector.ConditionRequireIf{
					Target: &reflector.Target{
						Field: "Bool",
						Unmarshaler: unmarshal.UnmarshalerName{
							Package: pkg,
							Type:    boolUnmarshaler,
						},
					},
					ValueStr: "true",
				},
			},
			"ENV_BOOL_DEP_S": {
				Target: &reflector.Target{
					Field: "BoolDepS",
					Unmarshaler: unmarshal.UnmarshalerName{
						Package: pkg,
						Type:    boolUnmarshaler,
					},
				},
				Condition: &reflector.ConditionRequireIf{
					Target: &reflector.Target{
						Field: "String",
						Unmarshaler: unmarshal.UnmarshalerName{
							Package: pkg,
							Type:    stringUnmarshaler,
						},
					},
					ValueStr: "foo",
				},
			},
			"ENV_STRING": {
				Target: &reflector.Target{
					Field: "String",
					Unmarshaler: unmarshal.UnmarshalerName{
						Package: pkg,
						Type:    stringUnmarshaler,
					},
				},
				Condition: reflector.ConditionRequired(true),
			},
			"ENV_CCC": {
				Target: &reflector.Target{
					Field: "Ccc",
					Unmarshaler: unmarshal.UnmarshalerName{
						Package: pkg,
						Type:    stringUnmarshaler,
					},
				},
				Condition: &reflector.ConditionRequireIfCombined{
					First: &reflector.ConditionRequireIf{
						Target: &reflector.Target{
							Field: "String",
							Unmarshaler: unmarshal.UnmarshalerName{
								Package: pkg,
								Type:    stringUnmarshaler,
							},
						},
						ValueStr: "foo",
					},
					Second: reflector.ConditionEnum([]string{"foo", "bar", "baz"}),
				},
			},
			"ENV_VERY_LOOOOOOOONG": {
				Target: &reflector.Target{
					Field: "URL",
					Unmarshaler: unmarshal.UnmarshalerName{
						Package: pkg,
						Type:    urlUnmarshaler,
					},
				},
				Condition: reflector.ConditionRequired(true),
			},
		},
	})
	if !assert.NoError(t, err) {
		fe := new(generator.CodegenError)
		if errors.As(err, &fe) {
			t.Log("\n" + fe.Details())
		}
		t.FailNow()
	}
	assert.Equal(t, expectedOutput, buf.String())
}
